{"categories":[{"title":"Golang","uri":"https://blog.marvel6.cn/categories/golang/"},{"title":"并发","uri":"https://blog.marvel6.cn/categories/%E5%B9%B6%E5%8F%91/"},{"title":"技巧","uri":"https://blog.marvel6.cn/categories/%E6%8A%80%E5%B7%A7/"},{"title":"翻译","uri":"https://blog.marvel6.cn/categories/%E7%BF%BB%E8%AF%91/"}],"posts":[{"content":" 背景 fork了很多代码库，现在想批量删除，只保留自己创建的代码库。\n解决方法：\n使用Github提供的开发者API\n1. 创建token 登录Github，按导航 “Settings/Developer settings”，切换到Tab “Personal access tokens”， 新生成一个token。选择 scope， “delelete_repo”。一次性操作，建议scope尽可能设置小范围，并且操作后删除该token。\n2. 获取待删除repo列表 按导航“settings/repositories”，选取并复制所有repo，粘贴到一个文本文件，处理后得到一个自己准备删除的repo列表。\n3. 请求删库API # 创建的token GITHUB_SECRET=\u0026quot;\u0026quot; # Curl请求API删除指定repo function git_repo_delete(){ curl -vL \\ -H \u0026quot;Authorization: token $GITHUB_SECRET\u0026quot; \\ -H \u0026quot;Content-Type: application/json\u0026quot; \\ -X DELETE https://api.github.com/repos/$1 } # helper: 获取指定范围内的一个随机整数 function mimvp_randnum_file() { min=$1 max=$2 mid=$(($max-$min+1)) num=$(head -n 20 /dev/urandom | cksum | cut -f1 -d ' ') randnum=$(($num%$mid+$min)) echo $randnum } repos=$(cat \u0026lt;repo_file\u0026gt;) for repo in $repos do echo \u0026quot;deleting $repo ...\u0026quot; git_repo_delete \u0026quot;$repo\u0026quot; # 随机sleep，1～3秒 rand=$(mimvp_randnum_file 1 3) sleep $rand done  思考 批量删库，Github为啥没有采取措施，如短时间拒绝访问，或者封号呢？\n如果Github 账号被盗，风险还是很大的。。。\n","id":0,"section":"posts","summary":"背景 fork了很多代码库，现在想批量删除，只保留自己创建的代码库。 解决方法： 使用Github提供的开发者API 1. 创建token 登录Githu","tags":["Github删库","小工具"],"title":"批量删除自己的Github仓库","uri":"https://blog.marvel6.cn/2019/11/delete-my-github-repos-in-bulk/","year":"2019"},{"content":" 你很可能从某种途径听说过 Go 语言。它越来越受欢迎，并且有充分的理由可以证明。 Go 快速、简单，有强大的社区支持。学习这门语言最令人兴奋的一点是它的并发模型。 Go 的并发原语使创建多线程并发程序变得简单而有趣。我将通过插图介绍 Go 的并发原语，希望能点透相关概念以方便后续学习。本文是写给 Go 语言编程新手以及准备开始学习 Go 并发原语 (go routines 和 channels) 的同学。\n单线程程序 vs. 多线程程序 你可能已经写过一些单线程程序。一个常用的编程模式是组合多个函数来执行一个特定任务，并且只有前一个函数准备好数据，后面的才会被调用。\n首先我们将用上述模式编写第一个例子的代码，一个描述挖矿的程序。它包含三个函数，分别负责执行寻矿、挖矿和练矿任务。在本例中，我们用一组字符串表示矿山和矿石，每个函数都以它们作为输入，并返回一组 “处理过的” 字符串。对于一个单线程的应用而言，该程序可能会按如下方式来设计：\n它有三个主要的函数：*finder*、miner 和 *smelter*。该版本的程序的所有函数都在单一线程中运行，一个接着一个执行，并且这个线程 (名为 Gary 的 gopher) 需要处理全部工作。\nfunc main() { theMine := [5]string{\u0026quot;rock\u0026quot;, \u0026quot;ore\u0026quot;, \u0026quot;ore\u0026quot;, \u0026quot;rock\u0026quot;, \u0026quot;ore\u0026quot;} foundOre := finder(theMine) minedOre := miner(foundOre) smelter(minedOre) }  在每个函数最后打印出 “矿石” 处理后的结果，得到如下输出：\nFrom Finder: [ore ore ore] From Miner: [minedOre minedOre minedOre] From Smelter: [smeltedOre smeltedOre smeltedOre]  这种编程风格具有易于设计的优点，但是当你想利用多个线程并执行彼此独立的函数时会发生什么呢？这就是并发程序设计发挥作用的地方。\n这种设计使得 “挖矿” 更高效。现在多个线程 (gophers) 是独立运行的，从而 Gary 不再承担全部工作。其中一个 gopher 负责寻矿，一个负责挖矿，另一个负责练矿，这些工作可能同时进行。\n为了将这种并发特性引入我们的代码，我们需要创建独立运行的 gophers 的方法以及它们之间彼此通信 (传送矿石) 的方法。这就需要用到 Go 的并发原语： goroutines 和 channels。\nGo routines Go routines 可以看作是轻量级线程。创建一个 Go routine 非常简单，只需要把 go 关键字放在函数调用语句前。为了说明这有多么简单，我们创建两个 finder 函数，并用 go 调用，让它们每次找到 “矿石” 就打印出来。\nfunc main() { theMine := [5]string{\u0026quot;rock\u0026quot;, \u0026quot;ore\u0026quot;, \u0026quot;ore\u0026quot;, \u0026quot;rock\u0026quot;, \u0026quot;ore\u0026quot;} go finder1(theMine) go finder2(theMine) \u0026lt;-time.After(time.Second * 5) //you can ignore this for now }  程序的输出如下:\nFinder 1 found ore! Finder 2 found ore! Finder 1 found ore! Finder 1 found ore! Finder 2 found ore! Finder 2 found ore!  可以看出，两个 finder 是并发运行的。哪一个先找到矿石没有确定的顺序，当执行多次程序时，这个顺序并不总是相同的。\n这是一个很大的进步！现在我们有一个简单的方法来创建多线程 (multi-gopher) 程序，但是当我们需要独立的 go routines 之间彼此通信会发生什么呢？欢迎来到神奇的 channels 世界。\nChannels Channels 允许 go routines 之间相互通信。你可以把 channel 看作管道，go routines 可以往里面发消息，也可以从中接收其它 go routines 的消息。\nmyFirstChannel := make(chan string)  Go routines 可以往 channel 发送消息，也可以从中接收消息。这是通过箭头操作符 (\u0026lt;-) 完成的，它指示 channel 中的数据流向。\nmyFirstChannel \u0026lt;-\u0026quot;hello\u0026quot; // Send myVariable := \u0026lt;- myFirstChannel // Receive  现在通过 channel 我们可以让寻矿 gopher 一找到矿石就立即传送给开矿 gopher ，而不用等发现所有矿石。\n我重写了挖矿程序，把寻矿和开矿函数改写成了未命名函数。如果你从未见过 lambda 函数，不必过多关注这部分，只需要知道每个函数将通过 go 关键字调用并运行在各自的 go routine 中。重要的是，要注意 go routine 之间是如何通过 channel oreChan 传递数据的。别担心，我会在最后面解释未命名函数的。\nfunc main() { theMine := [5]string{\u0026quot;ore1\u0026quot;, \u0026quot;ore2\u0026quot;, \u0026quot;ore3\u0026quot;} oreChan := make(chan string) // Finder go func(mine [5]string) { for _, item := range mine { oreChan \u0026lt;- item //send } }(theMine) // Ore Breaker go func() { for i := 0; i \u0026lt; 3; i++ { foundOre := \u0026lt;-oreChan //receive fmt.Println(\u0026quot;Miner: Received \u0026quot; + foundOre + \u0026quot; from finder\u0026quot;) } }() \u0026lt;-time.After(time.Second * 5) // Again, ignore this for now }  从下面的输出，可以看到 Miner 从 oreChan 读取了三次，每次接收一块矿石。\nMiner: Received ore1 from finder Miner: Received ore2 from finder Miner: Received ore3 from finder  太棒了，现在我们能在程序的 go routines(gophers) 之间发送数据了。在开始用 channels 写复杂的程序之前，我们先来理解它的一些关键特性。\nChannel Blocking Channels 阻塞 go routines 发生在各种情形下。这能在 go routines 各自欢快地运行之前，实现彼此之间的短暂同步。\nBlocking on a Send 一旦一个 go routine(gopher) 向一个 channel 发送数据，它就被阻塞了，直到另一个 go routine 从该 channel 取走数据。\nBlocking on a Receive 和发送时情形类似，一个 go routine 可能阻塞着等待从一个 channel 获取数据，如果还没有其他 go routine 往该 channel 发送数据。\n一开始接触阻塞的概念可能令人有些困惑，但你可以把它想象成两个 go routines(gophers) 之间的交易。 其中一个 gopher 无论是等着收钱还是送钱，都需要等待交易的另一方出现。\n既然已经了解 go routine 通过 channel 通信可能发生阻塞的不同情形，让我们讨论两种不同类型的 channels: unbuffered 和 buffered 。选择使用哪一种 channel 可能会改变程序的运行表现。\nUnbuffered Channels 在前面的例子中我们一直在用 unbuffered channels，它们与众不同的地方在于每次只有一份数据可以通过。\nBuffered Channels 在并发程序中，时间协调并不总是完美的。在挖矿的例子中，我们可能遇到这样的情形：开矿 gopher 处理一块矿石所花的时间，寻矿 gohper 可能已经找到 3 块矿石了。为了不让寻矿 gopher 浪费大量时间等着给开矿 gopher 传送矿石，我们可以使用 buffered channel。我们先创建一个容量为 3 的 buffered channel。\nbufferedChan := make(chan string, 3)  buffered 和 unbuffered channels 工作原理类似，但有一点不同—在需要另一个 go rountine 取走数据之前，我们可以向 buffered channel 发送多份数据。\nbufferedChan := make(chan string, 3) go func() { bufferedChan \u0026lt;-\u0026quot;first\u0026quot; fmt.Println(\u0026quot;Sent 1st\u0026quot;) bufferedChan \u0026lt;-\u0026quot;second\u0026quot; fmt.Println(\u0026quot;Sent 2nd\u0026quot;) bufferedChan \u0026lt;-\u0026quot;third\u0026quot; fmt.Println(\u0026quot;Sent 3rd\u0026quot;) }() \u0026lt;-time.After(time.Second * 1) go func() { firstRead := \u0026lt;- bufferedChan fmt.Println(\u0026quot;Receiving..\u0026quot;) fmt.Println(firstRead) secondRead := \u0026lt;- bufferedChan fmt.Println(secondRead) thirdRead := \u0026lt;- bufferedChan fmt.Println(thirdRead) }()  两个 go routines 之间的打印顺序如下：\nSent 1st Sent 2nd Sent 3rd Receiving.. first second third  为了简单起见，我们在最终的程序中不使用 buffered channels。但知道该使用哪种 channel 是很重要的。\n 注意: 使用 buffered channels 并不会避免阻塞发生。例如，如果寻矿 gopher 比开矿 gopher 执行速度快 10 倍，并且它们通过一个容量为 2 的 buffered channel 进行通信，那么寻矿 gopher 仍会发生多次阻塞。\n 把这些都放到一起 现在凭借 go routines 和 channels 的强大功能，我们可以使用 Go 的并发原语编写一个充分发挥多线程优势的程序了。\ntheMine := [5]string{\u0026quot;rock\u0026quot;, \u0026quot;ore\u0026quot;, \u0026quot;ore\u0026quot;, \u0026quot;rock\u0026quot;, \u0026quot;ore\u0026quot;} oreChannel := make(chan string) minedOreChan := make(chan string) // Finder go func(mine [5]string) { for _, item := range mine { if item == \u0026quot;ore\u0026quot; { oreChannel \u0026lt;- item //send item on oreChannel } } }(theMine) // Ore Breaker go func() { for i := 0; i \u0026lt; 3; i++ { foundOre := \u0026lt;-oreChannel //read from oreChannel fmt.Println(\u0026quot;From Finder:\u0026quot;, foundOre) minedOreChan \u0026lt;-\u0026quot;minedOre\u0026quot; //send to minedOreChan } }() // Smelter go func() { for i := 0; i \u0026lt; 3; i++ { minedOre := \u0026lt;-minedOreChan //read from minedOreChan fmt.Println(\u0026quot;From Miner:\u0026quot;, minedOre) fmt.Println(\u0026quot;From Smelter: Ore is smelted\u0026quot;) } }() \u0026lt;-time.After(time.Second * 5) // Again, you can ignore this  程序输出如下：\nFrom Finder: ore From Finder: ore From Miner: minedOre From Smelter: Ore is smelted From Miner: minedOre From Smelter: Ore is smelted From Finder: ore From Miner: minedOre From Smelter: Ore is smelted  相比最初的例子，已经有了很大改进！现在每个函数都独立地运行在各自的 go routines 中。此外，每次处理完一块矿石，它就会被带进挖矿流水线的下一个阶段。\n为了专注于理解 go routines 和 channel 的基本概念，上文有些重要的信息我没有提，如果不知道的话，当你开始编程时它们可能会造成一些麻烦。既然你已经理解了 go routines 和 channel 的工作原理，在开始用它们编写代码之前，让我们先了解一些你应该知道的其他信息。\n在开始之前，你应该知道\u0026hellip; 匿名的 Go routines 类似于如何利用 go 关键字使一个函数运行在自己的 go routine 中，我们可以用如下方式创建一个匿名函数并运行在它的 go routine 中：\n// Anonymous go routine go func() { fmt.Println(\u0026quot;I'm running in my own go routine\u0026quot;) }()  如果只需要调用一次函数，通过这种方式我们可以让它在自己的 go routine 中运行，而不需要创建一个正式的函数声明。\nmain 函数是一个 go routine main 函数确实运行在自己的 go routine 中！更重要的是要知道，一旦 main 函数返回，它将关掉当前正在运行的其他 go routines。这就是为什么我们在 main 函数的最后设置了一个定时器—它创建了一个 channel，并在 5 秒后发送一个值。\n\u0026lt;-time.After(time.Second * 5) //Receiving from channel after 5 sec  还记得 go routine 从 channel 中读数据如何被阻塞直到有数据发送到里面吧？通过添加上面这行代码，main routine 将会发生这种情况。它会阻塞，以给其他 go routines 5 秒的时间来运行。\n现在有更好的方式阻塞 main 函数直到其他所有 go routines 都运行完。通常的做法是创建一个 *done channel*， main 函数在等待读取它时被阻塞。一旦完成工作，向这个 channel 发送数据，程序就会结束了。\nfunc main() { doneChan := make(chan string) go func() { // Do some work… doneChan \u0026lt;- \u0026quot;I'm all done!\u0026quot; }() \u0026lt;-doneChan // block until go routine signals work is done }  你可以遍历 channel 在前面的例子中我们让 miner 在 for 循环中迭代 3 次从 channel 中读取数据。如果我们不能确切知道将从 finder 接收多少块矿石呢？ 好吧，类似于对集合数据类型 (注: 如 slice) 进行遍历，你也可以遍历一个 channel。\n更新前面的 miner 函数，我们可以这样写：\n// Ore Breaker go func() { for foundOre := range oreChan { fmt.Println(\u0026quot;Miner: Received \u0026quot; + foundOre + \u0026quot; from finder\u0026quot;) } }()  由于 miner 需要读取 finder 发送给它的所有数据，遍历 channel 能确保我们接收到已经发送的所有数据。\n 遍历 channel 会阻塞，直到有新数据被发送到 channel。在所有数据发送完之后避免 go routine 阻塞的唯一方法就是用 \u0026ldquo;close(channel)\u0026rdquo; 关掉 channel。\n 对 channel 进行非阻塞读 但你刚刚告诉我们 channel 如何阻塞 go routine 的各种情形？！没错，不过还有一个技巧，利用 Go 的 select case 语句可以实现对 channel 的非阻塞读。通过使用这这种语句，如果 channel 有数据，go routine 将会从中读取，否则就执行默认的分支。\nmyChan := make(chan string) go func(){ myChan \u0026lt;- \u0026quot;Message!\u0026quot; }() select { case msg := \u0026lt;- myChan: fmt.Println(msg) default: fmt.Println(\u0026quot;No Msg\u0026quot;) } \u0026lt;-time.After(time.Second * 1) select { case msg := \u0026lt;- myChan: fmt.Println(msg) default: fmt.Println(\u0026quot;No Msg\u0026quot;) }  程序输出如下:\nNo Msg Message!  对 channel 进行非阻塞写 非阻塞写也是使用同样的 select case 语句来实现，唯一不同的地方在于，case 语句看起来像是发送而不是接收。\nselect { case myChan \u0026lt;- \u0026quot;message\u0026quot;: fmt.Println(\u0026quot;sent the message\u0026quot;) default: fmt.Println(\u0026quot;no message sent\u0026quot;) }  接下来去哪儿学 有许多讲座和博客更详细地介绍了 channels 和 go routines。 既然已经对这些工具的目的和应用有了深刻的理解，那么你应该能够充分利用下面的文章和演讲了。\n Google I/O 2012 — Go Concurrency Patterns\nRob Pike — \u0026rsquo;Concurrency Is Not Parallelism\u0026rsquo;\nGopherCon 2017: Edward Muller — Go Anti-Patterns\n 谢谢您花时间阅读本文。我希望你能够理解 go routines 和 channels 基本概念，以及使用它们给编写并发程序带来的好处。\nvia: https://medium.com/@trevor4e/learning-gos-concurrency-through-illustrations-8c4aff603b3\n作者：Trevor Forrey 译者：mbyd916\n","id":1,"section":"posts","summary":"你很可能从某种途径听说过 Go 语言。它越来越受欢迎，并且有充分的理由可以证明。 Go 快速、简单，有强大的社区支持。学习这门语言最令人兴奋的一点是它的","tags":["Goroutine","Channel"],"title":"图解 Go 并发编程","uri":"https://blog.marvel6.cn/2019/02/learning-go-concurrency-through-illustrations/","year":"2019"}],"tags":[{"title":"Channel","uri":"https://blog.marvel6.cn/tags/channel/"},{"title":"Github删库","uri":"https://blog.marvel6.cn/tags/github%E5%88%A0%E5%BA%93/"},{"title":"Goroutine","uri":"https://blog.marvel6.cn/tags/goroutine/"},{"title":"小工具","uri":"https://blog.marvel6.cn/tags/%E5%B0%8F%E5%B7%A5%E5%85%B7/"}]}